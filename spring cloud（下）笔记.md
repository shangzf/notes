# spring cloud（下）笔记

[toc]

## 1、Spring Cloud⾼级进阶

### 1、微服务监控之 Turbine 聚合监控

### 2、微服务监控之分布式链路追踪技术 Sleuth + Zipkin

#### 1、分布式链路追踪技术适⽤场景（问题场景）

场景描述

为了⽀撑⽇益增⻓的庞⼤业务量，我们会使⽤微服务架构设计我们的系统，使得我们的系统不仅能 够通过集群部署抵挡流量的冲击，⼜能根据业务进⾏灵活的扩展。 那么，在微服务架构下，⼀次请求少则经过三四次服务调⽤完成，多则跨越⼏⼗个甚⾄是上百个服 务节点。那么问题接踵⽽来： 1）如何动态展示服务的调⽤链路？（⽐如A服务调⽤了哪些其他的服务---依赖关系） 2）如何分析服务调⽤链路中的瓶颈节点并对其进⾏调优？(⽐如A—>B—>C，C服务处理时间特别 ⻓) 3）如何快速进⾏服务链路的故障发现？ 这就是分布式链路追踪技术存在的⽬的和意义 分布式链路追踪技术 如果我们在⼀个请求的调⽤处理过程中，在各个链路节点都能够记录下⽇志，并最终将⽇志进⾏集 中可视化展示，那么我们想监控调⽤链路中的⼀些指标就有希望了~~~⽐如，请求到达哪个服务实 例？请求被处理的状态怎样？处理耗时怎样？这些都能够分析出来了... 分布式环境下基于这种想法实现的监控技术就是就是分布式链路追踪（全链路追踪）。 市场上的分布式链路追踪⽅案 分布式链路追踪技术已然成熟，产品也不少，国内外都有，⽐如

Spring Cloud Sleuth + Twitter Zipkin 阿⾥巴巴的“鹰眼” ⼤众点评的“CAT” 美团的“Mtrace” 京东的“Hydra” 新浪的“Watchman” 另外还有最近也被提到很多的Apache Skywalking。

#### 2、分布式链路追踪技术核⼼思想

本质：记录⽇志，作为⼀个完整的技术，分布式链路追踪也有⾃⼰的理论和概念

⼀个请求通过⽹关服务路由到下游的微服务-1，然后微服务-1调⽤微 服务-2，拿到结果后再调⽤微服务-3，最后组合微服务-2和微服务-3的结果，通过⽹关返回给⽤户 为了追踪整个调⽤链路，肯定需要记录⽇志，⽇志记录是基础，在此之上肯定有⼀些理论概念，当下主 流的的分布式链路追踪技术/系统所基于的理念都来⾃于Google的⼀篇论⽂《Dapper, a Large-Scale Distributed Systems Tracing Infrastructure》，这⾥⾯涉及到的核⼼理念是什么，我们来看下，还以 前⾯的服务调⽤来说

⼀个请求链路，⼀条链路通过TraceId唯⼀标识，span标识发起的请求信息，各span通过 parrentId关联起来 Trace：服务追踪的追踪单元是从客户发起请求（request）抵达被追踪系统的边界开始，到被追踪系统 向客户返回响应（response）为⽌的过程

Trace ID：为了实现请求跟踪，当请求发送到分布式系统的⼊⼝端点时，只需要服务跟踪框架为该请求 创建⼀个唯⼀的跟踪标识Trace ID，同时在分布式系统内部流转的时候，框架失踪保持该唯⼀标识，直 到返回给请求⽅

⼀个Trace由⼀个或者多个Span组成，每⼀个Span都有⼀个SpanId，Span中会记录TraceId，同时还有 ⼀个叫做ParentId，指向了另外⼀个Span的SpanId，表明⽗⼦关系，其实本质表达了依赖关系

Span ID：为了统计各处理单元的时间延迟，当请求到达各个服务组件时，也是通过⼀个唯⼀标识Span ID来标记它的开始，具体过程以及结束。对每⼀个Span来说，它必须有开始和结束两个节点，通过记录 开始Span和结束Span的时间戳，就能统计出该Span的时间延迟，除了时间戳记录之外，它还可以包含 ⼀些其他元数据，⽐如时间名称、请求信息等。

每⼀个Span都会有⼀个唯⼀跟踪标识 Span ID,若⼲个有序的 span 就组成了⼀个 trace。

Span可以认为是⼀个⽇志数据结构，在⼀些特殊的时机点会记录了⼀些⽇志信息，⽐如有时间戳、 spanId、TraceId，parentIde等，Span中也抽象出了另外⼀个概念，叫做事件，核⼼事件如下

CS ：client send/start 客户端/消费者发出⼀个请求，描述的是⼀个span开始 SR: server received/start 服务端/⽣产者接收请求 SR-CS属于请求发送的⽹络延迟 SS: server send/ﬁnish 服务端/⽣产者发送应答 SS-SR属于服务端消耗时间 CR：client received/ﬁnished 客户端/消费者接收应答 CR-SS表示回复需要的时间(响应的⽹络延 迟)

Spring Cloud Sleuth （追踪服务框架）可以追踪服务之间的调⽤，Sleuth可以记录⼀个服务请求经过哪 些服务、服务处理时⻓等，根据这些，我们能够理清各微服务间的调⽤关系及进⾏问题追踪分析。

耗时分析：通过 Sleuth 了解采样请求的耗时，分析服务性能问题（哪些服务调⽤⽐较耗时）

链路优化：发现频繁调⽤的服务，针对性优化等

Sleuth就是通过记录⽇志的⽅式来记录踪迹数据的

注意：我们往往把Spring Cloud Sleuth 和 Zipkin ⼀起使⽤，把 Sleuth 的数据信息发送给 Zipkin 进 ⾏聚合，利⽤ Zipkin 存储并展示数据。

#### 3、Sleuth + Zipkin

### 3、微服务统⼀认证⽅案 Spring Cloud OAuth2 + JWT

#### 1、微服务架构下统⼀认证思路

基于Session的认证⽅式 在分布式的环境下，基于session的认证会出现⼀个问题，每个应⽤服务都需要在session中存储⽤ 户身份信息，通过负载均衡将本地的请求分配到另⼀个应⽤服务需要将session信息带过去，否则 会重新认证。我们可以使⽤Session共享、Session黏贴等⽅案。

Session⽅案也有缺点，⽐如基于cookie，移动端不能有效使⽤等

基于token的认证⽅式

基于token的认证⽅式，服务端不⽤存储认证数据，易维护扩展性强， 客户端可以把token 存在任 意地⽅，并且可以实现web和app统⼀认证机制。其缺点也很明显，token由于⾃包含信息，因此 ⼀般数据量较⼤，⽽且每次请求 都需要传递，因此⽐较占带宽。另外，token的签名验签操作也会 给cpu带来额外的处理负担。

#### 2、OAuth2开放授权协议/标准

##### 1、OAuth2介绍

OAuth（开放授权）是⼀个开放协议/标准，允许⽤户授权第三⽅应⽤访问他们存储在另外的服务提供者 上的信息，⽽不需要将⽤户名和密码提供给第三⽅应⽤或分享他们数据的所有内容。

允许⽤户授权第三⽅应⽤访问他们存储在另外的服务提供者上的信息，⽽不需要将⽤户名和密码提供给 第三⽅应⽤或分享他们数据的所有内容

结合“使⽤QQ登录拉勾”这个场景拆分理解上述那句话

⽤户：我们⾃⼰

第三⽅应⽤：拉勾⽹

另外的服务提供者：QQ

OAuth2是OAuth协议的延续版本，但不向后兼容OAuth1即完全废⽌了OAuth1。

##### 2、OAuth2协议⻆⾊和流程

##### 3、什么情况下需要使⽤OAuth2？

第三⽅授权登录的场景：⽐如，我们经常登录⼀些⽹站或者应⽤的时候，可以选择使⽤第三⽅授权登录 的⽅式，⽐如：微信授权登录、QQ授权登录、微博授权登录等，这是典型的 OAuth2 使⽤场景。 单点登录的场景：如果项⽬中有很多微服务或者公司内部有很多服务，可以专⻔做⼀个认证中⼼（充当 认证平台⻆⾊），所有的服务都要到这个认证中⼼做认证，只做⼀次登录，就可以在多个授权范围内的 服务中⾃由串⾏。

##### 4、OAuth2的颁发Token授权⽅式

1）授权码（authorization-code） 2）密码式（password）提供⽤户名+密码换取token令牌 3）隐藏式（implicit） 4）客户端凭证（client credentials） 授权码模式使⽤到了回调地址，是最复杂的授权⽅式，微博、微信、QQ等第三⽅登录就是这种模式。 我们重点讲解接⼝对接中常使⽤的password密码模式（提供⽤户名+密码换取token）。

#### 3、Spring Cloud OAuth2 + JWT 实现

##### 1、Spring Cloud OAuth2介绍

Spring Cloud OAuth2 是 Spring Cloud 体系对OAuth2协议的实现，可以⽤来做多个微服务的统⼀认证 （验证身份合法性）授权（验证权限）。通过向OAuth2服务（统⼀认证授权服务）发送某个类型的 grant_type进⾏集中认证和授权，从⽽获得access_token（访问令牌），⽽这个token是受其他微服务 信任的。

注意：使⽤OAuth2解决问题的本质是，引⼊了⼀个认证授权层，认证授权层连接了资源的拥有者，在 授权层⾥⾯，资源的拥有者可以给第三⽅应⽤授权去访问我们的某些受保护资源。

##### 2、Spring Cloud OAuth2构建微服务统⼀认证服务思路

注意：在我们统⼀认证的场景中，Resource Server其实就是我们的各种受保护的微服务，微服务中的 各种API访问接⼝就是资源，发起http请求的浏览器就是Client客户端（对应为第三⽅应⽤）

##### 3、搭建认证服务器（Authorization Server）

##### 4、JWT改造统⼀认证授权中⼼的令牌存储机制

JWT令牌介绍 通过上边的测试我们发现，当资源服务和授权服务不在⼀起时资源服务使⽤RemoteTokenServices 远 程请求授权 服务验证token，如果访问量较⼤将会影响系统的性能。

解决上边问题： 令牌采⽤JWT格式即可解决上边的问题，⽤户认证通过会得到⼀个JWT令牌，JWT令牌 中已经包括了⽤户相关的信 息，客户端只需要携带JWT访问资源服务，资源服务根据事先约定的算法⾃ ⾏完成令牌校验，⽆需每次都请求认证 服务完成授权。

1）什么是JWT？ JSON Web Token（JWT）是⼀个开放的⾏业标准（RFC 7519），它定义了⼀种简介的、⾃包含的协议 格式，⽤于 在通信双⽅传递json对象，传递的信息经过数字签名可以被验证和信任。JWT可以使⽤ HMAC算法或使⽤RSA的公 钥/私钥对来签名，防⽌被篡改。

2）JWT令牌结构 JWT令牌由三部分组成，每部分中间使⽤点（.）分隔，⽐如：xxxxx.yyyyy.zzzzz

Header 头部包括令牌的类型（即JWT）及使⽤的哈希算法（如HMAC SHA256或RSA），例如

```
{

"alg": "HS256", "typ": "JWT"

}
```

将上边的内容使⽤Base64Url编码，得到⼀个字符串就是JWT令牌的第⼀部分。

Payload

第⼆部分是负载，内容也是⼀个json对象，它是存放有效信息的地⽅，它可以存放jwt提供的现成 字段，⽐ 如：iss（签发者）,exp（过期时间戳）, sub（⾯向的⽤户）等，也可⾃定义字段。 此部 分不建议存放敏感信息，因为此部分可以解码还原原始内容。 最后将第⼆部分负载使⽤Base64Url 编码，得到⼀个字符串就是JWT令牌的第⼆部分。 ⼀个例⼦：

```
{

"sub": "1234567890", "name": "John Doe", "iat": 1516239022

}
```

Signature

第三部分是签名，此部分⽤于防⽌jwt内容被篡改。 这个部分使⽤base64url将前两部分进⾏编 码，编码后使⽤点（.）连接组成字符串，最后使⽤header中声明 签名算法进⾏签名。

```
HMACSHA256(

base64UrlEncode(header) + "." + base64UrlEncode(payload), secret)
```

base64UrlEncode(header)：jwt令牌的第⼀部分。

base64UrlEncode(payload)：jwt令牌的第⼆部分。

secret：签名所使⽤的密钥。

##### 5、从数据库加载Oauth2客户端信息

##### 6、从数据库验证⽤户合法性

##### 7、基于Oauth2的 JWT 令牌信息扩展

OAuth2帮我们⽣成的JWT令牌载荷部分信息有限，关于⽤户信息只有⼀个user_name，有些场景下我 们希望放⼊⼀些扩展信息项，⽐如，之前我们经常向session中存⼊userId，或者现在我希望在JWT的载 荷部分存⼊当时请求令牌的客户端IP，客户端携带令牌访问资源服务时，可以对⽐当前请求的客户端真 实IP和令牌中存放的客户端IP是否匹配，不匹配拒绝请求，以此进⼀步提⾼安全性。那么如何在OAuth2 环境下向JWT令牌中存如扩展信息？

##### 8、资源服务器取出 JWT 令牌扩展信息

##### 9、其他

关于JWT令牌我们需要注意

JWT令牌就是⼀种可以被验证的数据组织格式，它的玩法很灵活，我们这⾥是基于Spring Cloud Oauth2 创建、校验JWT令牌 

我们也可以⾃⼰写⼯具类⽣成、校验JWT令牌 JWT令牌中不要存放过于敏感的信息，因为我们知道拿到令牌后，我们可以解码看到载荷部分的信息 

JWT令牌每次请求都会携带，内容过多，会增加⽹络带宽占⽤

## 2、第⼆代 Spring Cloud 核⼼组件（SCA）

第⼀代 Spring Cloud （主要是 SCN）很多组件已经进⼊停更维护模式。

Spring Cloud：Netﬂix，Spring官⽅，SCA（被Spring官⽅认可） 注意：市场上主要使⽤的还是SCN，SCA⼀套框架的集合

Alibaba 更进⼀步，搞出了Spring Cloud Alibaba（SCA），SCA 是由⼀些阿⾥巴巴的开源组件和云产品 组成的，2018年，Spring Cloud Alibaba 正式⼊住了 Spring Cloud 官⽅孵化器。 Nacos（服务注册中⼼、配置中⼼） Sentinel哨兵（服务的熔断、限流等） Dubbo RPC/LB Seata分布式事务解决⽅案

### 1、SCA Nacos 服务注册和配置中⼼

#### 1、Nacos 介绍

Nacos （Dynamic Naming and Conﬁguration Service）是阿⾥巴巴开源的⼀个针对微服务架构中服务 发现、配置管理和服务管理平台。 Nacos就是注册中⼼+配置中⼼的组合（Nacos=Eureka+Conﬁg+Bus） 官⽹：https://nacos.io 下载地址：https://github.com/alibaba/Nacos Nacos功能特性 服务发现与健康检查 动态配置管理 动态DNS服务 服务和元数据管理（管理平台的⻆度，nacos也有⼀个ui⻚⾯，可以看到注册的服务及其实例信息 （元数据信息）等），动态的服务权重调整、动态服务优雅下线，都可以去做

#### 2、Nacos 单例服务部署

#### 3、Nacos 服务注册中⼼

#### 4、Nacos 配置中⼼

### 2、SCA Sentinel 分布式系统的流量防卫兵

#### 1、Sentinel 介绍

Sentinel是⼀个⾯向云原⽣微服务的流量控制、熔断降级组件。 替代Hystrix，针对问题：服务雪崩、服务降级、服务熔断、服务限流 

Hystrix： 服务消费者（⾃动投递微服务）—>调⽤服务提供者（简历微服务） 在调⽤⽅引⼊Hystrix—> 单独搞了⼀个Dashboard项⽬—>Turbine 

1）⾃⼰搭建监控平台 dashboard 

2）没有提供UI界⾯进⾏服务熔断、服务降级等配置（⽽是写代码，⼊侵了我们源程序环境） 

Sentinel： 

1）独⽴可部署Dashboard/控制台组件 

2）减少代码开发，通过UI界⾯配置即可完成细粒度控制

Sentinel 分为两个部分:

核⼼库：（Java 客户端）不依赖任何框架/库，能够运⾏于所有 Java 运⾏时环境，同时对 Dubbo / Spring Cloud 等框架也有较好的⽀持。 控制台：（Dashboard）基于 Spring Boot 开发，打包后可以直接运⾏，不需要额外的 Tomcat 等 应⽤容器。

Sentinel 具有以下特征:

丰富的应⽤场景：Sentinel 承接了阿⾥巴巴近 10 年的双⼗⼀⼤促流量的核⼼场景，例如秒杀（即 突发流量控制在系统容量可以承受的范围）、消息削峰填⾕、集群流量控制、实时熔断下游不可⽤ 应⽤等。 完备的实时监控：Sentinel 同时提供实时的监控功能。您可以在控制台中看到接⼊应⽤的单台机器 秒级数据，甚⾄ 500 台以下规模的集群的汇总运⾏情况。 ⼴泛的开源⽣态：Sentinel 提供开箱即⽤的与其它开源框架/库的整合模块，例如与 Spring Cloud、Dubbo的整合。您只需要引⼊相应的依赖并进⾏简单的配置即可快速地接⼊ Sentinel。 完善的 SPI 扩展点：Sentinel 提供简单易⽤、完善的 SPI 扩展接⼝。您可以通过实现扩展接⼝来快 速地定制逻辑。例如定制规则管理、适配动态数据源等。

#### 2、Sentinel 部署

#### 3、服务改造

#### 4、Sentinel 关键概念

| 概 念 名 称 | 概念描述                                                     |
| ----------- | ------------------------------------------------------------ |
| 资 源       | 它可以是 Java 应⽤程序中的任何内容，例如，由应⽤程序提供的服务，或由应⽤程序调⽤ 的其它应⽤提供的服务，甚⾄可以是⼀段代码。我们请求的API接⼝就是资源 |
| 规 则       | 围绕资源的实时状态设定的规则，可以包括流量控制规则、熔断降级规则以及系统保护规 则。所有规则可以动态实时调整。 |

#### 5、Sentinel 流量规则模块

系统并发能⼒有限，⽐如系统A的QPS⽀持1个，如果太多请求过来，那么A就应该进⾏流量控制了，⽐ 如其他请求直接拒绝。

资源名：默认请求路径 针对来源：Sentinel可以针对调⽤者进⾏限流，填写微服务名称，默认default（不区分来源） 阈值类型/单机阈值 QPS：（每秒钟请求数量）当调⽤该资源的QPS达到阈值时进⾏限流 线程数：当调⽤该资源的线程数达到阈值的时候进⾏限流（线程处理请求的时候，如果说业务逻辑执⾏ 时间很⻓，流量洪峰来临时，会耗费很多线程资源，这些线程资源会堆积，最终可能造成服务不可⽤， 进⼀步上游服务不可⽤，最终可能服务雪崩） 是否集群：是否集群限流 流控模式： 直接：资源调⽤达到限流条件时，直接限流 关联：关联的资源调⽤达到阈值时候限流⾃⼰ 链路：只记录指定链路上的流量 流控效果： 快速失败：直接失败，抛出异常 Warm Up：根据冷加载因⼦（默认3）的值，从阈值/冷加载因⼦，经过预热时⻓，才达到设置的QPS阈 值 排队等待：匀速排队，让请求匀速通过，阈值类型必须设置为QPS，否则⽆效 流控模式之关联限流** 关联的资源调⽤达到阈值时候限流⾃⼰，⽐如⽤户注册接⼝，需要调⽤身份证校验接⼝（往往身份证校 验接⼝），如果身份证校验接⼝请求达到阈值，使⽤关联，可以对⽤户注册接⼝进⾏限流。

流控模式之链路限流

链路指的是请求链路（调⽤链）

链路模式下会控制该资源所在的调⽤链路⼊⼝的流量。需要在规则中配置⼊⼝资源，即该调⽤链路⼊⼝ 的上下⽂名称。

流控效果之Warm up

当系统⻓期处于空闲的情况下，当流量突然增加时，直接把系统拉升到⾼⽔位可能瞬间把系统压垮，⽐ 如电商⽹站的秒杀模块。

通过 Warm Up 模式（预热模式），让通过的流量缓慢增加，经过设置的预热时间以后，到达系统处理 请求速率的设定值。

Warm Up 模式默认会从设置的 QPS 阈值的 1/3 开始慢慢往上增加⾄ QPS 设置值。

流控效果之排队等待

排队等待模式下会严格控制请求通过的间隔时间，即请求会匀速通过，允许部分请求排队等待，通常⽤ 于消息队列削峰填⾕等场景。需设置具体的超时时间，当计算的等待时间超过超时时间时请求就会被拒 绝。

很多流量过来了，并不是直接拒绝请求，⽽是请求进⾏排队，⼀个⼀个匀速通过（处理），请求能等就 等着被处理，不能等（等待时间>超时时间）就会被拒绝

例如，QPS 配置为 5，则代表请求每 200 ms 才能通过⼀个，多出的请求将排队等待通过。超时时间代 表最⼤排队时间，超出最⼤排队时间的请求将会直接被拒绝。排队等待模式下，QPS 设置值不要超过 1000（请求间隔 1 ms）。

#### 6、Sentinel 降级规则模块

流控是对外部来的⼤流量进⾏控制，熔断降级的视⻆是对内部问题进⾏处理。

Sentinel 降级会在调⽤链路中某个资源出现不稳定状态时（例如调⽤超时或异常⽐例升⾼），对这个资 源的调⽤进⾏限制，让请求快速失败，避免影响到其它的资源⽽导致级联错误。当资源被降级后，在接 下来的降级时间窗⼝之内，对该资源的调⽤都⾃动熔断.

策略

Sentinel不会像Hystrix那样放过⼀个请求尝试⾃我修复，就是明明确确按照时间窗⼝来，熔断触发后， 时间窗⼝内拒绝请求，时间窗⼝后就恢复。

RT（平均响应时间 ）

当 1s 内持续进⼊ >=5 个请求，平均响应时间超过阈值（以 ms 为单位），那么在接下的时间窗⼝ （以 s 为单位）之内，对这个⽅法的调⽤都会⾃动地熔断（抛出 DegradeException）。注意 Sentinel 默认统计的 RT 上限是 4900 ms，超出此阈值的都会算作 4900 ms，若需要变更此上限 可以通过启动配置项 -Dcsp.sentinel.statistic.max.rt=xxx 来配置。

异常⽐例

当资源的每秒请求量 >= 5，并且每秒异常总数占通过量的⽐值超过阈值之后，资源进⼊降级状 态，即在接下的时间窗⼝（以 s 为单位）之内，对这个⽅法的调⽤都会⾃动地返回。异常⽐率的阈 值范围是 [0.0, 1.0] ，代表 0% - 100%。

异常数 当资源近 1 分钟的异常数⽬超过阈值之后会进⾏熔断。注意由于统计时间窗⼝是分钟级别的，若 timeWindow ⼩于 60s，则结束熔断状态后仍可能再进⼊熔断状态。

#### 7、Sentinel ⾃定义兜底逻辑

@SentinelResource注解类似于Hystrix中的@HystrixCommand注解 @SentinelResource注解中有两个属性需要我们进⾏区分，blockHandler属性⽤来指定不满⾜Sentinel 规则的降级兜底⽅法，fallback属性⽤于指定Java运⾏时异常兜底⽅法

#### 8、基于 Nacos 实现 Sentinel 规则持久化

### 3、Nacos + Sentinel + Dubbo 三剑合璧

### 4、SCA ⼩结

SCA实际上发展了三条线

第⼀条线：开源出来⼀些组件 

第⼆条线：阿⾥内部维护了⼀个分⽀，⾃⼰业务线使⽤ 

第三条线：阿⾥云平台部署⼀套，付费使⽤ 从战略上来说，SCA更是为了贴合阿⾥云。 ⽬前来看，开源出来的这些组件，推⼴及普及率不⾼，社区活跃度不⾼，稳定性和体验度上仍需进 ⼀步提升，根据实际使⽤来看Sentinel的稳定性和体验度要好于Nacos。