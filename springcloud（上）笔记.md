# springcloud（上）笔记

[toc]

## 1、微服务架构

### 1、互联⽹应⽤架构发展（回顾）

随着互联⽹的发展，⽤户群体逐渐扩⼤，⽹站的流量成倍增⻓，常规的单体架构已⽆法满⾜请求压⼒和 业务的快速迭代，架构的变化势在必⾏。下⾯我们就以拉勾⽹的架构演进为例，从最开始的单体架构分 析，⼀步步的到现在的微服务架构。

1）单体应⽤架构

在诞⽣之初，拉勾的⽤户量、数据量规模都⽐较⼩，项⽬所有的功能模块都放在⼀个⼯程中编码、编 译、打包并且部署在⼀个Tomcat容器中的架构模式就是单体应⽤架构，这样的架构既简单实 ⽤、便于 维护，成本⼜低，成为了那个时代的主流架构⽅式。

优点：

项⽬前期开发节奏快，团队成员少的时候能够快速迭代 架构简单：MVC架构，只需要借助IDE开发、调试即可 易于测试：只需要通过单元测试或者浏览器完成 易于部署：打包成单⼀可执⾏的jar或者打成war包放到容器内启动 缺点： 随着不断的功能迭代，单个项⽬过⼤，代码杂乱，耦合严重，开发团队逐渐壮⼤以后，沟通 成本 变⾼， 如：代码从编译到启动耗时达到 3-5 分钟 新增业务困难：在已经乱如麻的系统中增加新业务，维护旧功能，⼀脚踩进去全是不可预测 的问 题。新⼈来了以后很难接⼿任务，学习成本⾼，需要⼤概 ⼀周时间 才能上⼿开发 核⼼业务与边缘业务混合在⼀块，出现问题互相影响，如：⼀个临时活动流量猛涨，机器负 载升 ⾼就会影响正常的业务服务 业务量上涨之后，单体应⽤架构进⼀步丰富变化，⽐如应⽤集群部署、使⽤Nginx进⾏负载均衡、增加 缓存服务器、增加⽂件服务器、数据库集群并做读写分离等，通过以上措施增强应对⾼并发的能⼒、应 对⼀定的复杂业务场景，但依然属于单体应⽤架构。

2）垂直应⽤架构

为了避免上⾯提到的那些问题，开始做模块的垂直划分，做垂直划分的原则是基于拉勾现有的业 务特性 来做，核⼼⽬标第⼀个是为了业务之间互不影响，第⼆个是在研发团队的壮⼤后为了提⾼ 效率，减少之 间的依赖。

优点

系统拆分实现了流量分担，解决了并发问题

可以针对不同模块进⾏优化

⽅便⽔平扩展，负载均衡，容错率提⾼

系统间相互独⽴，互不影响，新的业务迭代时更加⾼效

缺点

服务之间相互调⽤，如果某个服务的端⼝或者ip地址发⽣改变，调⽤的系统得⼿动改变

搭建集群之后，实现负载均衡⽐较复杂，如：内⽹负载，在迁移机器时会影响调⽤⽅的路 由，导 致线上故障

服务之间调⽤⽅式不统⼀，基于 httpclient 、 webservice ，接⼝协议不统⼀

服务监控不到位：除了依靠端⼝、进程的监控，调⽤的成功率、失败率、总耗时等等这些监 控指 标是没有的

3）SOA应⽤架构

在做了垂直划分以后，模块随之增多，维护的成本在也变⾼，⼀些通⽤的业务和模块重复的越来越多， 为了解决上⾯提到的接⼝协议不统⼀、服务⽆法监控、服务的负载均衡，引⼊了阿⾥巴巴开源的 Dubbo ，⼀款⾼性能、轻量级的开源Java RPC框架，它提供了三⼤核⼼能⼒：⾯向接⼝的远程⽅法调 ⽤，智能容错和负载均衡，以及服务⾃动注册和发现。

SOA (Service-Oriented Architecture)，即⾯向服务的架构。根据实际业务，把系统拆分成合适的、独 ⽴部署的模块，模块之间相互独⽴（通过Webservice/Dubbo等技术进⾏通信）。

优点：分布式、松耦合、扩展灵活、可重⽤。

缺点：服务抽取粒度较⼤、服务调⽤⽅和提供⽅耦合度较⾼（接⼝耦合度）

微服务应⽤架构

微服务架构可以说是SOA架构的⼀种拓展，这种架构模式下它拆分粒度更⼩、服务更独⽴。把应⽤拆分 成为⼀个个微⼩的服务，不同的服务可以使⽤不同的开发语⾔和存储，服务之间往往通过Restful等轻量 级通信。微服务架构关键在于微⼩、独⽴、轻量级通信。

微服务是在 SOA 上做的升华粒度更加细致，微服务架构强调的⼀个重点是“业务需要彻底的组件化 和服 务化”

微服务架构和SOA架构相似⼜不同

微服务架构和SOA架构很明显的⼀个区别就是服务拆分粒度的不同，但是对于拉勾的架构发展来 说，我们所看到的SOA阶段其实服务拆分粒度相对来说已经⽐较细了（超前哦！），所以上述拉勾 SOA到拉勾微服务，从服务拆分上来说变化并不⼤，只是引⼊了相对完整的新⼀代Spring Cloud微 服务技术。⾃然，上述我们看到的都是拉勾架构演变的阶段结果，每⼀个阶段其实都经历了很多变 化，拉勾的服务拆分其实也是⾛过了从粗到细，并⾮绝对的⼀步到位。

举个拉勾案例来说明SOA和微服务拆分粒度不同

我们在SOA架构的初期，“简历投递模块”和“⼈才搜索模块”都有简历内容展示的需求，只不过说可 能略有区别，⼀开始在两个模块中各维护了⼀套简历查询和展示的代码；后期我们将服务更细粒度 拆分，拆分出简历基础服务，那么不同模块调⽤这个基础服务即可。

### 2、微服务架构体现的思想及优缺点

微服务架构设计的核⼼思想就是“微”，拆分的粒度相对⽐较⼩，这样的话单⼀职责、开发的耦合度就会 降低、微⼩的功能可以独⽴部署扩展、灵活性强，升级改造影响范围⼩。

单体应⽤（1.7—>1.8）

A(升级JDK) B C D E ..... 微服务架构的优点: 微服务架构和微服务

微服务很⼩，便于特定业务功能的聚焦 A B C D 微服务很⼩，每个微服务都可以被⼀个⼩团队单独实施（开发、测试、部署上线、运维），团队合 作⼀定程度解耦，便于实施敏捷开发 微服务很⼩，便于重⽤和模块之间的组装 微服务很独⽴，那么不同的微服务可以使⽤不同的语⾔开发，松耦合 微服务架构下，我们更容易引⼊新技术 微服务架构下，我们可以更好的实现DevOps开发运维⼀体化；

微服务架构的缺点

微服务架构下，分布式复杂难以管理，当服务数量增加，管理将越加复杂； 微服务架构下，分布式链路跟踪难等；

### 3、微服务架构中的⼀些概念

服务注册与服务发现 

服务注册：服务提供者将所提供服务的信息（服务器IP和端⼝、服务访问协议等）注册/登记到注册中⼼ 服务发现：服务消费者能够从注册中⼼获取到较为实时的服务列表，然后根究⼀定的策略选择⼀个服务 访问

负载均衡

负载均衡即将请求压⼒分配到多个服务器（应⽤服务器、数据库服务器等），以此来提⾼服务的性 能、可靠性

熔断

熔断即断路保护。微服务架构中，如果下游服务因访问压⼒过⼤⽽响应变慢或失败，上游服务为了保护 系统整体可⽤性，可以暂时切断对下游服务的调⽤。这种牺牲局部，保全整体的措施就叫做熔断。

链路追踪 

微服务架构越发流⾏，⼀个项⽬往往拆分成很多个服务，那么⼀次请求就需要涉及到很多个服务。不同 的微服务可能是由不同的团队开发、可能使⽤不同的编程语⾔实现、整个项⽬也有可能部署在了很多服 务器上（甚⾄百台、千台）横跨多个不同的数据中⼼。所谓链路追踪，就是对⼀次请求涉及的很多个服 务链路进⾏⽇志记录、性能监控

API ⽹关

微服务架构下，不同的微服务往往会有不同的访问地址，客户端可能需要调⽤多个服务的接⼝才能完成 ⼀个业务需求，如果让客户端直接与各个微服务通信可能出现：

1）客户端需要调⽤不同的url地址，增加了维护调⽤难度

2）在⼀定的场景下，也存在跨域请求的问题（前后端分离就会碰到跨域问题，原本我们在后端采⽤ Cors就能解决，现在利⽤⽹关，那么就放在⽹关这层做好了）

3）每个微服务都需要进⾏单独的身份认证 那么，API⽹关就可以较好的统⼀处理上述问题，API请求调⽤统⼀接⼊API⽹关层，由⽹关转发请求。 API⽹关更专注在安全、路由、流量等问题的处理上（微服务团队专注于处理业务逻辑即可），它的功 能⽐如

1）统⼀接⼊（路由） 2）安全防护（统⼀鉴权，负责⽹关访问身份认证验证，与“访问认证中⼼”通信，实际认证业务逻辑交移 “访问认证中⼼”处理）

3）⿊⽩名单（实现通过IP地址控制禁⽌访问⽹关功能，控制访问）

3）协议适配（实现通信协议校验、适配转换的功能） 4）流量管控（限流） 5）⻓短链接⽀持 6）容错能⼒（负载均衡）

## 2、Spring Cloud 综述

### 1、Spring Cloud 是什么

Spring Cloud是⼀系列框架的有序集合。它利⽤Spring Boot的开发便利性巧妙地简化了分布

式系统基础设施的开发，如服务发现注册、配置中⼼、消息总线、负载均衡、断路器、数据监控等，都 可以⽤ Spring Boot的开发⻛格做到⼀键启动和部署。Spring Cloud并没有重复制造轮⼦，它只是将⽬ 前各家公司开发的⽐较成熟、经得起实际考验的服务框架组合起来，通过Spring Boot⻛格进⾏再封装 屏蔽掉了复杂的配置和实现原理，最终给开发者留出了⼀套简单易懂、易部署和易维护的分布式系统开 发⼯具包。

Spring Cloud是⼀系列框架的有序集合（Spring Cloud是⼀个规范）

开发服务发现注册、配置中⼼、消息总线、负载均衡、断路器、数据监控等

利⽤Spring Boot的开发便利性简化了微服务架构的开发（⾃动装配）

### 2、Spring Cloud 解决什么问题

Spring Cloud 规范及实现意图要解决的问题其实就是微服务架构实施过程中存在的⼀些问题，⽐如微服 务架构中的服务注册发现问题、⽹络问题（⽐如熔断场景）、统⼀认证安全授权问题、负载均衡问题、 链路追踪等问题。

### 3、Spring Cloud 架构

Spring Cloud是⼀个微服务相关规范，这个规范意图为搭建微服务架构提供⼀站式服务，采 ⽤组件（框架）化机制定义⼀系列组件，各类组件针对性的处理微服务中的特定问题，这些组件共同来 构成Spring Cloud微服务技术栈。

#### 1、Spring Cloud 核⼼组件

Spring Cloud ⽣态圈中的组件，按照发展可以分为第⼀代 Spring Cloud组件和第⼆代 Spring Cloud组 件。

|                 | 第⼀代 Spring Cloud（Netﬂix，SCN）                    | 第⼆代 Spring Cloud（主要就是Spring Cloud Alibaba，SCA） |
| --------------- | ----------------------------------------------------- | -------------------------------------------------------- |
| 注册中⼼        | Netﬂix Eureka                                         | 阿⾥巴巴 Nacos                                           |
| 客户端负 载均衡 | Netﬂix Ribbon                                         | 阿⾥巴巴 Dubbo LB、Spring Cloud Loadbalancer             |
| 熔断器          | Netﬂix Hystrix                                        | 阿⾥巴巴 Sentinel                                        |
| ⽹关            | Netﬂix Zuul：性能⼀般，未来将退出 Spring Cloud ⽣态圈 | 官⽅ Spring Cloud Gateway                                |
| 配置中⼼        | 官⽅ Spring Cloud Conﬁg                               | 阿⾥巴巴 Nacos、携程 Apollo                              |
| 服务调⽤        | Netﬂix Feign                                          | 阿⾥巴巴 Dubbo RPC                                       |
| 消息驱动        | 官⽅ Spring Cloud Stream                              |                                                          |
| 链路追踪        | 官⽅ Spring Cloud Sleuth/Zipkin                       |                                                          |
|                 |                                                       | 阿⾥巴巴 seata 分布式事务⽅案                            |

#### 2、Spring Cloud 体系结构（组件协同⼯作机制）

Spring Cloud中的各组件协同⼯作，才能够⽀持⼀个完整的微服务架构。⽐如

注册中⼼负责服务的注册与发现，很好将各服务连接起来 API⽹关负责转发所有外来的请求 断路器负责监控服务之间的调⽤情况，连续多次失败进⾏熔断保护。 配置中⼼提供了统⼀的配置信息管理服务,可以实时的通知各个服务获取最新的配置信息

### 4、Spring Cloud 与 Dubbo 对⽐

Dubbo是阿⾥巴巴公司开源的⼀个⾼性能优秀的服务框架，基于RPC调⽤，对于⽬前使⽤率较⾼的 Spring Cloud Netﬂix来说，它是基于HTTP的，所以效率上没有Dubbo⾼，但问题在于Dubbo体系的组 件不全，不能够提供⼀站式解决⽅案，⽐如服务注册与发现需要借助于Zookeeper等实现，⽽Spring Cloud Netﬂix则是真正的提供了⼀站式服务化解决⽅案，且有Spring⼤家族背景。

前些年，Dubbo使⽤率⾼于SpringCloud，但⽬前Spring Cloud在服务化/微服务解决⽅案中已经有了⾮ 常好的发展趋势。

### 5、Spring Cloud 与 Spring Boot 的关系

Spring Cloud 只是利⽤了Spring Boot 的特点，让我们能够快速的实现微服务组件开发，否则不使⽤ Spring Boot的话，我们在使⽤Spring Cloud时，每⼀个组件的相关Jar包都需要我们⾃⼰导⼊配置以及 需要开发⼈员考虑兼容性等各种情况。所以Spring Boot是我们快速把Spring Cloud微服务技术应⽤起 来的⼀种⽅式。

## 3、案例

## 4、第⼀代 Spring Cloud 核⼼组件

### 1、Eureka服务注册中⼼

#### 1、关于服务注册中⼼

注意：服务注册中⼼本质上是为了解耦服务提供者和服务消费者。

对于任何⼀个微服务，原则上都应存在或者⽀持多个提供者（⽐如简历微服务部署多个实例），这是由 微服务的分布式属性决定的。

更进⼀步，为了⽀持弹性扩缩容特性，⼀个微服务的提供者的数量和分布往往是动态变化的，也是⽆法 预先确定的。因此，原本在单体应⽤阶段常⽤的静态LB机制就不再适⽤了，需要引⼊额外的组件来管理 微服务提供者的注册与发现，⽽这个组件就是服务注册中⼼。

##### 1、服务注册中⼼⼀般原理

分布式微服务架构中，服务注册中⼼⽤于存储服务提供者地址信息、服务发布相关的属性信息，消费者 通过主动查询和被动通知的⽅式获取服务提供者的地址信息，⽽不再需要通过硬编码⽅式得到提供者的 地址信息。消费者只需要知道当前系统发布了那些服务，⽽不需要知道服务具体存在于什么位置，这就 是透明化路由。

1）服务提供者启动 

2）服务提供者将相关服务信息主动注册到注册中⼼ 3）服务消费者获取服务注册信息： poll模式：服务消费者可以主动拉取可⽤的服务提供者清单 push模式：服务消费者订阅服务（当服务提供者有变化时，注册中⼼也会主动推送更新后的服务清单给 消费者 4）服务消费者直接调⽤服务提供者 另外，注册中⼼也需要完成服务提供者的健康监控，当发现服务提供者失效时需要及时剔除；

##### 2、主流服务中⼼对⽐

Zookeeper

Zookeeper它是⼀个分布式服务框架，是Apache Hadoop 的⼀个⼦项⽬，它主要是⽤来解决分布 式应 ⽤中经常遇到的⼀些数据管理问题，如：统⼀命名服务、状态同步服务、集群管理、分布式 应⽤配置项的管理等。

简单来说zookeeper本质=存储+监听通知。

znode Zookeeper ⽤来做服务注册中⼼，主要是因为它具有节点变更通知功能，只要客户端监听相关服 务节点，服务节点的所有变更，都能及时的通知到监听客户端，这样作为调⽤⽅只要使⽤ Zookeeper 的客户端就能实现服务节点的订阅和变更通知功能了，⾮常⽅便。另外，Zookeeper 可⽤性也可以，因为只要半数以上的选举节点存活，整个集群就是可⽤的。3

Eureka

由Netﬂix开源，并被Pivatal集成到SpringCloud体系中，它是基于 RestfulAPI ⻛格开发的服务注册 与发现组件。

Consul

Consul是由HashiCorp基于Go语⾔开发的⽀持多数据中⼼分布式⾼可⽤的服务发布和注册服务软 件， 采⽤Raft算法保证服务的⼀致性，且⽀持健康检查。

Nacos

Nacos是⼀个更易于构建云原⽣应⽤的动态服务发现、配置管理和服务管理平台。简单来说 Nacos 就是 注册中⼼ + 配置中⼼的组合，帮助我们解决微服务开发必会涉及到的服务注册 与发现，服务 配置，服务管理等问题。Nacos 是 Spring Cloud Alibaba 核⼼组件之⼀，负责服务注册与发现， 还有配置。

| 组件名    | 语⾔ | CAP                          | 对外暴露接⼝ |
| --------- | ---- | ---------------------------- | ------------ |
| Eureka    | Java | AP（⾃我保护机制，保证可⽤） | HTTP         |
| Consul    | Go   | CP                           | HTTP/DNS     |
| Zookeeper | Java | CP                           | 客户端       |
| Nacos     | Java | ⽀持AP/CP切换                | HTTP         |

P：分区容错性（⼀定的要满⾜的） C：数据⼀致性 A：⾼可⽤ CAP不可能同时满⾜三个，要么是AP，要么是CP

#### 2、服务注册中⼼组件 Eureka

服务注册中⼼的⼀般原理、对⽐了主流的服务注册中⼼⽅案 ⽬光聚焦Eureka

Eureka 包含两个组件：Eureka Server 和 Eureka Client，Eureka Client是⼀个Java客户端，⽤于 简化与Eureka Server的交互；Eureka Server提供服务发现的能⼒，各个微服务启动时，会通过 Eureka Client向Eureka Server 进⾏注册⾃⼰的信息（例如⽹络信息），Eureka Server会存储该 服务的信息；

1）图中us-east-1c、us-east-1d，us-east-1e代表不同的区也就是不同的机房

2）图中每⼀个Eureka Server都是⼀个集群。

3）图中Application Service作为服务提供者向Eureka Server中注册服务，Eureka Server接受到 注册事件会在集群和分区中进⾏数据同步，Application Client作为消费端（服务消费者）可以从 Eureka Server中获取到服务注册信息，进⾏服务调⽤。

4）微服务启动后，会周期性地向Eureka Server发送⼼跳（默认周期为30秒）以续约⾃⼰的信息

5）Eureka Server在⼀定时间内没有接收到某个微服务节点的⼼跳，Eureka Server将会注销该微 服务节点（默认90秒）

6）每个Eureka Server同时也是Eureka Client，多个Eureka Server之间通过复制的⽅式完成服务 注册列表的同步

7）Eureka Client会缓存Eureka Server中的信息。即使所有的Eureka Server节点都宕掉，服务消 费者依然可以使⽤缓存中的信息找到服务提供者

Eureka通过⼼跳检测、健康检查和客户端缓存等机制，提⾼系统的灵活性、可伸缩性和可⽤性。

#### 3、Eureka应⽤及⾼可⽤集群

#### 4、Eureka细节详解

##### 1、Eureka元数据详解

Eureka的元数据有两种：标准元数据和⾃定义元数据。 标准元数据：主机名、IP地址、端⼝号等信息，这些信息都会被发布在服务注册表中，⽤于服务之间的 调⽤。 ⾃定义元数据：可以使⽤eureka.instance.metadata-map配置，符合KEY/VALUE的存储格式。这 些元 数据可以在远程客户端中访问。

##### 2、Eureka客户端详解

服务提供者（也是Eureka客户端）要向EurekaServer注册服务，并完成服务续约等⼯作 服务注册详解（服务提供者） 1）当我们导⼊了eureka-client依赖坐标，配置Eureka服务注册中⼼地址 2）服务在启动时会向注册中⼼发起注册请求，携带服务元数据信息 3）Eureka注册中⼼会把服务的信息保存在Map中。 服务续约详解（服务提供者）

服务每隔30秒会向注册中⼼续约(⼼跳)⼀次（也称为报活），如果没有续约，租约在90秒后到期，然后 服务会被失效。每隔30秒的续约操作我们称之为⼼跳检测

##### 3、Eureka服务端详解

服务下线

 1）当服务正常关闭操作时，会发送服务下线的REST请求给EurekaServer。 

2）服务中⼼接受到请求后，将该服务置为下线状态 

失效剔除

 Eureka Server会定时（间隔值是eureka.server.eviction-interval-timer-in-ms，默认60s）进⾏检查， 如果发现实例在在⼀定时间（此值由客户端设置的eureka.instance.lease-expiration-duration-inseconds定义，默认值为90s）内没有收到⼼跳，则会注销此实例。 

⾃我保护 

服务提供者 —> 注册中⼼ 定期的续约（服务提供者和注册中⼼通信），假如服务提供者和注册中⼼之间的⽹络有点问题，不代表 服务提供者不可⽤，不代表服务消费者⽆法访问服务提供者 如果在15分钟内超过85%的客户端节点都没有正常的⼼跳，那么Eureka就认为客户端与注册中⼼出现了 ⽹络故障，Eureka Server⾃动进⼊⾃我保护机制。 为什么会有⾃我保护机制？ 默认情况下，如果Eureka Server在⼀定时间内（默认90秒）没有接收到某个微服务实例的⼼跳， Eureka Server将会移除该实例。但是当⽹络分区故障发⽣时，微服务与Eureka Server之间⽆法正常通 信，⽽微服务本身是正常运⾏的，此时不应该移除这个微服务，所以引⼊了⾃我保护机制。

当处于⾃我保护模式时 

1）不会剔除任何服务实例（可能是服务提供者和EurekaServer之间⽹络问题），保证了⼤多数服务依 然可⽤ 

2）Eureka Server仍然能够接受新服务的注册和查询请求，但是不会被同步到其它节点上，保证当前节 点依然可⽤，当⽹络稳定时，当前Eureka Server新的注册信息会被同步到其它节点中。 

3）在Eureka Server⼯程中通过eureka.server.enable-self-preservation配置可⽤关停⾃我保护，默认 值是打开

#### 5、Eureka核⼼源码剖析

##### 1、Eureka Server启动过程

##### 2、Eureka Server服务接⼝暴露策略

##### 3、Eureka Server服务注册接⼝（接受客户端注册服务）

##### 4、Eureka Server服务续约接⼝（接受客户端续约）

##### 5、Eureka Client注册服务

##### 6、Eureka Client下架服务

##### 7、Eureka Client⼼跳续约

### 2、Ribbon负载均衡

#### 1、关于负载均衡

负载均衡⼀般分为服务器端负载均衡和客户端负载均衡

所谓服务器端负载均衡，⽐如Nginx、F5这些，请求到达服务器之后由这些负载均衡器根据⼀定的算法 将请求路由到⽬标服务器处理。

所谓客户端负载均衡，⽐如我们要说的Ribbon，服务消费者客户端会有⼀个服务器地址列表，调⽤⽅在 请求前通过⼀定的负载均衡算法选择⼀个服务器进⾏访问，负载均衡算法的执⾏是在请求客户端进⾏。

Ribbon是Netﬂix发布的负载均衡器。Eureka⼀般配合Ribbon进⾏使⽤，Ribbon利⽤从Eureka中读取到 服务信息，在调⽤服务提供者提供的服务时，会根据⼀定的算法进⾏负载。

#### 2、Ribbon⾼级应⽤

#### 3、Ribbon负载均衡策略

#### 4、Ribbon核⼼源码剖析

##### 1、@LoadBalanced源码剖析

##### 2、RoundRobinRule轮询策略源码剖析

##### 3、RandomRule随机策略源码剖析

### 3、Hystrix熔断器

#### 1、微服务中的雪崩效应

什么是微服务中的雪崩效应呢？

微服务中，⼀个请求可能需要多个微服务接⼝才能实现，会形成复杂的调⽤链路。

在微服务架构中，⼀个应⽤可能会有多个微服务组成，微服务之间的数据交互通过远程过程调⽤完成。 这就带来⼀个问题，假设微服务A调⽤微服务B和微服务C，微服务B和微服务C⼜调⽤其它的微服务，这 就是所谓的“扇出”。如果扇出的链路上某个微服务的调⽤响应时间过⻓或者不可⽤，对微服务A的调⽤就 会占⽤越来越多的系统资源，进⽽引起系统崩溃，所谓的“雪崩效应”。

最下游简历微服务响应时间过⻓，⼤量请求阻塞，⼤量线程不会释放，会导致服务器资源 耗尽，最终导致上游服务甚⾄整个系统瘫痪。

#### 2、雪崩效应解决⽅案

从可⽤性可靠性着想，为防⽌系统的整体缓慢甚⾄崩溃，采⽤的技术⼿段；

下⾯，我们介绍三种技术⼿段应对微服务中的雪崩效应，这三种⼿段都是从系统可⽤性、可靠性⻆度出 发，尽量防⽌系统整体缓慢甚⾄瘫痪。

服务熔断

熔断机制是应对雪崩效应的⼀种微服务链路保护机制。我们在各种场景下都会接触到熔断这两个字。⾼ 压电路中，如果某个地⽅的电压过⾼，熔断器就会熔断，对电路进⾏保护。股票交易中，如果股票指数 过⾼，也会采⽤熔断机制，暂停股票的交易。同样，在微服务架构中，熔断机制也是起着类似的作⽤。 当扇出链路的某个微服务不可⽤或者响应时间太⻓时，熔断该节点微服务的调⽤，进⾏服务的降级，快 速返回错误的响应信息。当检测到该节点微服务调⽤响应正常后，恢复调⽤链路。

注意：

1）服务熔断重点在“断”，切断对下游服务的调⽤

2）服务熔断和服务降级往往是⼀起使⽤的，Hystrix就是这样。

服务降级

通俗讲就是整体资源不够⽤了，先将⼀些不关紧的服务停掉（调⽤我的时候，给你返回⼀个预留的值， 也叫做兜底数据），待渡过难关⾼峰过去，再把那些服务打开。 服务降级⼀般是从整体考虑，就是当某个服务熔断之后，服务器将不再被调⽤，此刻客户端可以⾃⼰准 备⼀个本地的fallback回调，返回⼀个缺省值，这样做，虽然服务⽔平下降，但好⽍可⽤，⽐直接挂掉 要强。

服务限流

服务降级是当服务出问题或者影响到核⼼流程的性能时，暂时将服务屏蔽掉，待⾼峰或者问题解决后再 打开；但是有些场景并不能⽤服务降级来解决，⽐如秒杀业务这样的核⼼功能，这个时候可以结合服务 限流来限制这些场景的并发/请求量

限流措施也很多，⽐如

限制总并发数（⽐如数据库连接池、线程池） 限制瞬时并发数（如nginx限制瞬时并发连接数） 限制时间窗⼝内的平均速率（如Guava的RateLimiter、nginx的limit_req模块，限制每秒的平均速 率） 限制远程接⼝调⽤速率、限制MQ的消费速率等

#### 3、Hystrix简介

Hystrix（豪猪----->刺），宣⾔“defend your app”是由Netﬂix开源的⼀个延迟和容错库，⽤ 于隔离访问远程系统、服务或者第三⽅库，防⽌级联失败，从⽽提升系统的可⽤性与容错性。Hystrix主 要通过以下⼏点实现延迟和容错。

包裹请求：使⽤HystrixCommand包裹对依赖的调⽤逻辑。 ⾃动投递微服务⽅法 （@HystrixCommand 添加Hystrix控制） ——调⽤简历微服务 跳闸机制：当某服务的错误率超过⼀定的阈值时，Hystrix可以跳闸，停⽌请求该服务⼀段时间。 资源隔离：Hystrix为每个依赖都维护了⼀个⼩型的线程池(舱壁模式)（或者信号量）。如果该线程 池已满， 发往该依赖的请求就被⽴即拒绝，⽽不是排队等待，从⽽加速失败判定。 监控：Hystrix可以近乎实时地监控运⾏指标和配置的变化，例如成功、失败、超时、以及被拒绝 的请求等。 回退机制：当请求失败、超时、被拒绝，或当断路器打开时，执⾏回退逻辑。回退逻辑由开发⼈员 ⾃⾏提供，例如返回⼀个缺省值。 ⾃我修复：断路器打开⼀段时间后，会⾃动进⼊“半开”状态。

#### 4、Hystrix熔断应⽤

#### 5、Hystrix舱壁模式（线程池隔离策略）

#### 6、Hystrix⼯作流程与⾼级应⽤

#### 7、Hystrix Dashboard断路监控仪表盘

#### 8、Hystrix Turbine聚合监控

#### 9、Hystrix核⼼源码剖析

### 4、Feign远程调⽤组件

#### 1、Feign简介

Feign是Netﬂix开发的⼀个轻量级RESTful的HTTP服务客户端（⽤它来发起请求，远程调⽤的），是以 Java接⼝注解的⽅式调⽤Http请求，⽽不⽤像Java中通过封装HTTP请求报⽂的⽅式直接调⽤，Feign被 ⼴泛应⽤在Spring Cloud 的解决⽅案中。

类似于Dubbo，服务消费者拿到服务提供者的接⼝，然后像调⽤本地接⼝⽅法⼀样去调⽤，实际发出的 是远程的请求。

Feign可帮助我们更加便捷，优雅的调⽤HTTP API：不需要我们去拼接url然后呢调⽤ restTemplate的api，在SpringCloud中，使⽤Feign⾮常简单，创建⼀个接⼝（在消费者--服务调 ⽤⽅这⼀端），并在接⼝上添加⼀些注解，代码就完成了 SpringCloud对Feign进⾏了增强，使Feign⽀持了SpringMVC注解（OpenFeign）

本质：封装了Http调⽤流程，更符合⾯向接⼝化的编程习惯，类似于Dubbo的服务调⽤

#### 2、Feign配置应⽤

#### 3、Feign对负载均衡的⽀持

#### 4、Feign对熔断器的⽀持

#### 5、Feign对请求压缩和响应压缩的⽀持

#### 6、Feign的⽇志级别配置

#### 7、Feign核⼼源码剖析

### 5、GateWay⽹关组件

#### 1、GateWay简介

Spring Cloud GateWay是Spring Cloud的⼀个全新项⽬，⽬标是取代Netﬂix Zuul，它基于 Spring5.0+SpringBoot2.0+WebFlux（基于⾼性能的Reactor模式响应式通信框架Netty，异步⾮阻塞模 型）等技术开发，性能⾼于Zuul，官⽅测试，GateWay是Zuul的1.6倍，旨在为微服务架构提供⼀种简 单有效的统⼀的API路由管理⽅式。

Spring Cloud GateWay不仅提供统⼀的路由⽅式（反向代理）并且基于 Filter(定义过滤器对请求过滤， 完成⼀些功能) 链的⽅式提供了⽹关基本的功能，例如：鉴权、流量控制、熔断、路径重写、⽇志监控 等。

#### 2、GateWay核⼼概念

#### 3、GateWay⼯作过程

#### 4、GateWay应⽤

#### 5、GateWay路由规则详解

#### 6、GateWay动态路由详解

#### 7、GateWay过滤器

#### 8、GateWay⾼可⽤

### 6、Spring Cloud Conﬁg 分布式配置中⼼

#### 1、分布式配置中⼼应⽤场景

往往，我们使⽤配置⽂件管理⼀些配置信息，⽐如application.yml 单体应⽤架构，配置信息的管理、维护并不会显得特别麻烦，⼿动操作就可以，因为就⼀个⼯程； 微服务架构，因为我们的分布式集群环境中可能有很多个微服务，我们不可能⼀个⼀个去修改配置然后 重启⽣效，在⼀定场景下我们还需要在运⾏期间动态调整配置信息，⽐如：根据各个微服务的负载情 况，动态调整数据源连接池⼤⼩，我们希望配置内容发⽣变化的时候，微服务可以⾃动更新。 场景总结如下： 1）集中配置管理，⼀个微服务架构中可能有成百上千个微服务，所以集中配置管理是很重要的（⼀次 修改、到处⽣效） 2）不同环境不同配置，⽐如数据源配置在不同环境（开发dev,测试test,⽣产prod）中是不同的 3）运⾏期间可动态调整。例如，可根据各个微服务的负载情况，动态调整数据源连接池⼤⼩等配置修 改后可⾃动更新 4）如配置内容发⽣变化，微服务可以⾃动更新配置 那么，我们就需要对配置⽂件进⾏集中式管理，这也是分布式配置中⼼的作⽤。

#### 2、Spring Cloud Conﬁg

##### 1、Conﬁg简介

Spring Cloud Conﬁg是⼀个分布式配置管理⽅案，包含了 Server端和 Client端两个部分。

##### 2、Conﬁg分布式配置应⽤

#### 3、Conﬁg配置⼿动刷新

不⽤重启微服务，只需要⼿动的做⼀些其他的操作（访问⼀个地址/refresh）刷新，之后再访问即可

此时，客户端取到了配置中⼼的值，但当我们修改GitHub上⾯的值时，服务端（Conﬁg Server）能实 时获取最新的值，但客户端（Conﬁg Client）读的是缓存，⽆法实时获取最新值。Spring Cloud已 经为 我们解决了这个问题，那就是客户端使⽤post去触发refresh，获取最新数据。

#### 4、Conﬁg配置⾃动更新

##### 1、消息总线Bus

所谓消息总线Bus，即我们经常会使⽤MQ消息代理构建⼀个共⽤的Topic，通过这个Topic连接各个微服 务实例，MQ⼴播的消息会被所有在注册中⼼的微服务实例监听和消费。换⾔之就是通过⼀个主题连接 各个微服务，打通脉络。

Spring Cloud Bus（基于MQ的，⽀持RabbitMq/Kafka） 是Spring Cloud中的消息总线⽅案，Spring Cloud Conﬁg + Spring Cloud Bus 结合可以实现配置信息的⾃动更新。

##### 2、Spring Cloud Conﬁg+Spring Cloud Bus 实现⾃动刷新

### 7、Spring Cloud Stream消息驱动组件

#### 1、Stream解决的痛点问题

MQ消息中间件⼴泛应⽤在应⽤解耦合、异步消息处理、流量削峰等场景中。 不同的MQ消息中间件内部机制包括使⽤⽅式都会有所不同，⽐如RabbitMQ中有Exchange（交换机/交 换器）这⼀概念，kafka有Topic、Partition分区这些概念，MQ消息中间件的差异性不利于我们上层的 开发应⽤，当我们的系统希望从原有的RabbitMQ切换到Kafka时，我们会发现⽐较困难，很多要操作可 能重来（因为应⽤程序和具体的某⼀款MQ消息中间件耦合在⼀起了）。 Spring Cloud Stream进⾏了很好的上层抽象，可以让我们与具体消息中间件解耦合，屏蔽掉了底层具 体MQ消息中间件的细节差异，就像Hibernate屏蔽掉了具体数据库（Mysql/Oracle⼀样）。如此⼀ 来，我们学习、开发、维护MQ都会变得轻松。⽬前Spring Cloud Stream⽀持RabbitMQ和Kafka。 本质：屏蔽掉了底层不同MQ消息中间件之间的差异，统⼀了MQ的编程模型，降低了学习、开发、维 护MQ的成本

#### 2、Stream重要概念

Spring Cloud Stream 是⼀个构建消息驱动微服务的框架。应⽤程序通过inputs（相当于消息消费者 consumer）或者outputs（相当于消息⽣产者producer）来与Spring Cloud Stream中的binder对象交 互，⽽Binder对象是⽤来屏蔽底层MQ细节的，它负责与具体的消息中间件交互。

说⽩了：对于我们来说，只需要知道如何使⽤Spring Cloud Stream与Binder对象交互即可

#### 3、传统MQ模型与Stream消息驱动模型

#### 4、Stream消息通信⽅式及编程模型

##### 1、Stream消息通信⽅式

Stream中的消息通信⽅式遵循了发布—订阅模式。

在Spring Cloud Stream中的消息通信⽅式遵循了发布-订阅模式，当⼀条消息被投递到消息中间件之

后，它会通过共享的 Topic 主题进⾏⼴播，消息消费者在订阅的主题中收到它并触发⾃身的业务逻辑处 理。这⾥所提到的 Topic 主题是Spring Cloud Stream中的⼀个抽象概念，⽤来代表发布共享消息给消 费者的地⽅。在不同的消息中间件中， Topic 可能对应着不同的概念，⽐如：在RabbitMQ中的它对应 了Exchange、在Kakfa中则对应了Kafka中的Topic。

##### 2、Stream编程注解

如下的注解⽆⾮在做⼀件事，把我们结构图中那些组成部分上下关联起来，打通通道（这样的话⽣产者 的message数据才能进⼊mq，mq中数据才能进⼊消费者⼯程）。

| 注解                                                      | 描述                                                       |
| --------------------------------------------------------- | ---------------------------------------------------------- |
| @Input（在消费者⼯程中使⽤）                              | 注解标识输⼊通道，通过该输⼊通道接收到的 消息进⼊应⽤程序  |
| @Output（在⽣产者⼯程中使⽤）                             | 注解标识输出通道，发布的消息将通过该通道 离开应⽤程序      |
| @StreamListener（在消费者⼯程中使⽤，监 听message的到来） | 监听队列，⽤于消费者的队列的消息的接收 （有消息监听.....） |
| @EnableBinding                                            | 把Channel和Exchange（对于RabbitMQ）绑 定在⼀起             |

##### 3、Stream消息驱动之开发⽣产者端

##### 4、Stream消息驱动之开发消费者端

#### 5、Stream⾼级之⾃定义消息通道

Stream 内置了两种接⼝Source和Sink分别定义了 binding 为 “input” 的输⼊流和 “output” 的输出流， 我们也可以⾃定义各种输⼊输出流（通道），但实际我们可以在我们的服务中使⽤多个binder、多个输 ⼊通道和输出通道，然⽽默认就带了⼀个input的输⼊通道和⼀个output的输出通道，怎么办？

我们是可以⾃定义消息通道的，学着Source和Sink的样⼦，给你的通道定义个⾃⼰的名字，多个输⼊通 道和输出通道是可以写在⼀个类中的。

#### 6、Stream⾼级之消息分组

## 5、常⻅问题及解决⽅案





